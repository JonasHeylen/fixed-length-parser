package be.coiba.fixedlength

import cats.effect.Sync
import cats.implicits._
import fs2._

object StreamParser {
  def parseRecord[F[_]: Sync](s: Stream[F, String], definition: RecordDefinition): F[Record] =
    s.mapAccumulate(definition.fields -> "") {
        case ((fieldDefs @ (fieldDef :: xs), acc), in)
            if fieldDef.length <= acc.length + in.length =>
          val finalState = fieldDefs.foldLeft(ParserState(fieldDefs, acc + in, Nil)) {
            case (state, _) =>
              println(state)
              val fieldDefinition = state.fieldDefs.head
              if (state.rest.length >= fieldDefinition.length) {
                val (fieldValue, remainder) = state.rest.splitAt(fieldDefinition.length)
                ParserState(state.fieldDefs.tail, remainder, state.fields :+ Field(fieldDefinition.name, fieldValue))
              } else {
                state
              }
          }
          (finalState.fieldDefs, finalState.rest) -> Stream.emits(finalState.fields)
        case ((Nil, _), _)          => (Nil, "") -> Stream.empty
        case ((fieldDefs, acc), in) => (fieldDefs, acc + in) -> Stream.empty
      }
      .map(_._2)
      .flatten
      .compile
      .toList
      .map { parsedFields =>
        parsedFields ++ definition.fields
          .drop(parsedFields.size)
          .map(fieldDef => Field(fieldDef.name, ""))
      }
      .map(Record)

  final case class ParserState(fieldDefs: List[FieldDefinition], rest: String, fields: List[Field])
}
